<!-- Atomic Glow - OPTIMIZED Version -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atomic Glow - Optimized</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #f8fafc; min-height: 100vh; overflow: hidden; }
    .glow-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #f8fafc;
      overflow: hidden;
    }
    #glow-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .content-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      text-align: center;
      color: #1f2937;
      pointer-events: none;
    }
    .content-overlay h1 {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
    }
    .stats {
      position: fixed;
      top: 10px;
      left: 10px;
      font-family: monospace;
      font-size: 12px;
      color: #666;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div class="stats" id="stats"></div>
  <div class="glow-container">
    <canvas id="glow-canvas"></canvas>
    <div class="content-overlay">
      <h1>Leagues of Code</h1>
    </div>
  </div>

  <script>
  const AtomicGlow = (function() {
    'use strict';

    let canvas, ctx;
    let width, height;
    let time = 0;
    let animationId;
    let particles = [];

    // FPS tracking
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 60;

    // === OPTIMIZATION 1: Reduced particle count ===
    const PARTICLE_COUNT = 250; // Was 600

    // === OPTIMIZATION 2: Pre-computed colors as strings ===
    const colorStrings = [
      'rgba(59,130,246,',   // Blue
      'rgba(96,165,250,',   // Light blue
      'rgba(16,185,129,',   // Green
      'rgba(52,211,153,',   // Light green
      'rgba(6,182,212,',    // Cyan
    ];

    // === OPTIMIZATION 3: Simplified noise (cheaper than Perlin) ===
    const noise = (x, y, t) => {
      return Math.sin(x * 0.01 + t) * Math.cos(y * 0.01 + t * 0.7) * 0.5;
    };

    // === OPTIMIZATION 4: Pre-calculate sin/cos tables ===
    const SIN_TABLE = new Float32Array(360);
    const COS_TABLE = new Float32Array(360);
    for (let i = 0; i < 360; i++) {
      SIN_TABLE[i] = Math.sin(i * Math.PI / 180);
      COS_TABLE[i] = Math.cos(i * Math.PI / 180);
    }

    function fastSin(angle) {
      const idx = ((angle * 57.2958) % 360 + 360) % 360 | 0;
      return SIN_TABLE[idx];
    }

    function fastCos(angle) {
      const idx = ((angle * 57.2958) % 360 + 360) % 360 | 0;
      return COS_TABLE[idx];
    }

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * Math.min(width, height) * 0.35;
        this.x = width / 2 + Math.cos(angle) * dist;
        this.y = height / 2 + Math.sin(angle) * dist;
        this.vx = 0;
        this.vy = 0;

        // === OPTIMIZATION 5: Pre-compute per-particle values ===
        this.size = 2 + Math.random() * 4;
        this.colorIdx = (Math.random() * colorStrings.length) | 0;
        this.speed = 0.00002 + Math.random() * 0.00004; // Even slower orbit
        this.offset = Math.random() * 1000;
        this.layer = 0.6 + Math.random() * 0.8;
        this.baseOpacity = 0.3 + Math.random() * 0.4;
      }

      update(centerX, centerY, baseRadius, t) {
        // Target position with simple noise
        const angle = Math.atan2(this.y - centerY, this.x - centerX);
        const n = noise(this.x, this.y, t * 0.001); // Even slower noise
        const targetR = baseRadius * this.layer * (1 + n * 0.25);
        const orbitAngle = angle + t * this.speed;

        const targetX = centerX + fastCos(orbitAngle) * targetR;
        const targetY = centerY + fastSin(orbitAngle) * targetR;

        // === OPTIMIZATION 6: Simplified physics - SLOWER ===
        const dx = targetX - this.x;
        const dy = targetY - this.y;

        // Gentler attraction, stronger damping
        this.vx = (this.vx + dx * 0.001) * 0.9;
        this.vy = (this.vy + dy * 0.001) * 0.9;

        // Clamp max velocity to prevent acceleration
        const maxVel = 0.8;
        this.vx = Math.max(-maxVel, Math.min(maxVel, this.vx));
        this.vy = Math.max(-maxVel, Math.min(maxVel, this.vy));

        this.x += this.vx;
        this.y += this.vy;
      }

      draw(ctx, t) {
        // Size pulsing - slow breathing effect
        const pulse = 0.8 + Math.sin(t * 0.008 + this.offset) * 0.3;
        const size = this.size * pulse;

        ctx.beginPath();
        ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
        ctx.fillStyle = colorStrings[this.colorIdx] + this.baseOpacity + ')';
        ctx.fill();
      }
    }

    function init(canvasId) {
      canvas = document.getElementById(canvasId);
      if (!canvas) return;

      ctx = canvas.getContext('2d');

      // === OPTIMIZATION 8: Disable image smoothing ===
      ctx.imageSmoothingEnabled = false;

      resize();
      window.addEventListener('resize', resize);
      createParticles();
      animate();
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    function createParticles() {
      particles = [];
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push(new Particle());
      }
    }

    function animate() {
      time++;

      // FPS counter
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
        document.getElementById('stats').textContent =
          `FPS: ${fps} | Particles: ${PARTICLE_COUNT}`;
      }

      const centerX = width / 2;
      const centerY = height / 2;
      const baseRadius = Math.min(width, height) * 0.28;

      // === OPTIMIZATION 9: Higher trail opacity = less overdraw needed ===
      ctx.fillStyle = 'rgba(248, 250, 252, 0.2)';
      ctx.fillRect(0, 0, width, height);

      // === OPTIMIZATION 10: Apply blur once via CSS shadow, not per-particle ===
      ctx.shadowBlur = 8;
      ctx.shadowColor = 'rgba(59, 130, 246, 0.3)';

      // Update and draw all particles
      for (let i = 0; i < particles.length; i++) {
        particles[i].update(centerX, centerY, baseRadius, time);
        particles[i].draw(ctx, time);
      }

      // Reset shadow for next frame
      ctx.shadowBlur = 0;

      animationId = requestAnimationFrame(animate);
    }

    function destroy() {
      if (animationId) cancelAnimationFrame(animationId);
      window.removeEventListener('resize', resize);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => init('glow-canvas'));
    } else {
      init('glow-canvas');
    }

    return { init, destroy };
  })();
  </script>
</body>
</html>
