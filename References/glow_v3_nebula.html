<!-- Glow V3 - Nebula with scattered sparks -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V3 - Nebula</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0a; min-height: 100vh; overflow: hidden; }
    .glow-container { position: relative; width: 100vw; height: 100vh; background: #050208; overflow: hidden; }
    #glow-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .content-overlay {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 10; text-align: center; color: white; pointer-events: none;
    }
    .content-overlay h1 {
      font-family: 'Segoe UI', sans-serif; font-size: 2.5rem; font-weight: 600;
      letter-spacing: 2px; text-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    .version-label {
      position: fixed; top: 20px; left: 20px; color: white; font-family: 'Segoe UI', sans-serif;
      font-size: 14px; opacity: 0.6; z-index: 100;
    }
  </style>
</head>
<body>
  <div class="version-label">V3 - Nebula (soft clouds + bright sparks)</div>
  <div class="glow-container">
    <canvas id="glow-canvas"></canvas>
    <div class="content-overlay">
      <h1>My Vibe</h1>
    </div>
  </div>

  <script>
  (function() {
    'use strict';
    let canvas, ctx, width, height, time = 0;
    let sparks = [], clouds = [];

    const colors = [
      { r: 255, g: 220, b: 80 },
      { r: 255, g: 160, b: 50 },
      { r: 255, g: 100, b: 80 },
      { r: 230, g: 70, b: 140 },
      { r: 180, g: 60, b: 160 },
    ];

    const noise = (function() {
      const p = [];
      for (let i = 0; i < 256; i++) p[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [p[i], p[j]] = [p[j], p[i]];
      }
      const perm = [...p, ...p];
      function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      function lerp(a, b, t) { return a + t * (b - a); }
      function grad(hash, x, y) {
        const h = hash & 3;
        return ((h & 1) ? -(h < 2 ? x : y) : (h < 2 ? x : y)) + ((h & 2) ? -(h < 2 ? y : x) : (h < 2 ? y : x));
      }
      return function(x, y) {
        const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
        x -= Math.floor(x); y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const A = perm[X] + Y, B = perm[X + 1] + Y;
        return lerp(lerp(grad(perm[A], x, y), grad(perm[B], x - 1, y), u),
                    lerp(grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1), u), v);
      };
    })();

    class Cloud {
      constructor() {
        this.x = width / 2 + (Math.random() - 0.5) * width * 0.5;
        this.y = height / 2 + (Math.random() - 0.5) * height * 0.5;
        this.size = 100 + Math.random() * 200;
        this.colorIdx = Math.floor(Math.random() * colors.length);
        this.noiseOffset = Math.random() * 1000;
        this.driftSpeed = 0.2 + Math.random() * 0.3;
        this.opacity = 0.05 + Math.random() * 0.1;
      }

      update() {
        const n = noise(this.x * 0.001 + this.noiseOffset, time * 0.003);
        this.x += Math.cos(n * Math.PI * 2) * this.driftSpeed;
        this.y += Math.sin(n * Math.PI * 2) * this.driftSpeed;

        // Keep near center
        const dx = width / 2 - this.x, dy = height / 2 - this.y;
        this.x += dx * 0.002;
        this.y += dy * 0.002;
      }

      draw() {
        const c = colors[this.colorIdx];
        const pulse = 1 + Math.sin(time * 0.01 + this.noiseOffset) * 0.2;

        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * pulse);
        gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, ${this.opacity * 1.5})`);
        gradient.addColorStop(0.4, `rgba(${c.r}, ${c.g}, ${c.b}, ${this.opacity * 0.5})`);
        gradient.addColorStop(1, 'transparent');

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
    }

    class Spark {
      constructor() { this.reset(); }
      reset() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * Math.min(width, height) * 0.35;
        this.x = width / 2 + Math.cos(angle) * dist;
        this.y = height / 2 + Math.sin(angle) * dist;
        this.size = 1 + Math.random() * 3;
        this.brightness = 0;
        this.maxBrightness = 0.6 + Math.random() * 0.4;
        this.fadeSpeed = 0.01 + Math.random() * 0.02;
        this.state = 'in'; // in, hold, out
        this.holdTime = 0;
        this.maxHold = 20 + Math.random() * 40;
        this.colorIdx = Math.floor(Math.random() * colors.length);
        this.twinkleOffset = Math.random() * Math.PI * 2;
      }

      update() {
        if (this.state === 'in') {
          this.brightness += this.fadeSpeed * 2;
          if (this.brightness >= this.maxBrightness) {
            this.brightness = this.maxBrightness;
            this.state = 'hold';
          }
        } else if (this.state === 'hold') {
          this.holdTime++;
          if (this.holdTime > this.maxHold) this.state = 'out';
        } else {
          this.brightness -= this.fadeSpeed;
          if (this.brightness <= 0) this.reset();
        }
      }

      draw() {
        if (this.brightness <= 0) return;
        const c = colors[this.colorIdx];
        const twinkle = 0.7 + Math.sin(time * 0.1 + this.twinkleOffset) * 0.3;
        const alpha = this.brightness * twinkle;

        // Glow
        const glowSize = this.size * 6;
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
        gradient.addColorStop(0.2, `rgba(${c.r}, ${c.g}, ${c.b}, ${alpha * 0.6})`);
        gradient.addColorStop(1, 'transparent');
        ctx.beginPath();
        ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Core with rays
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Cross rays
        if (this.size > 2) {
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
          ctx.lineWidth = 0.5;
          const rayLen = this.size * 4 * twinkle;
          ctx.beginPath();
          ctx.moveTo(this.x - rayLen, this.y);
          ctx.lineTo(this.x + rayLen, this.y);
          ctx.moveTo(this.x, this.y - rayLen);
          ctx.lineTo(this.x, this.y + rayLen);
          ctx.stroke();
        }
      }
    }

    function drawCentralGlow() {
      const centerX = width / 2, centerY = height / 2;
      const radius = Math.min(width, height) * 0.35;
      const colorIdx = Math.floor(time * 0.008) % colors.length;
      const c = colors[colorIdx];

      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
      gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, 0.2)`);
      gradient.addColorStop(0.5, `rgba(${c.r}, ${c.g}, ${c.b}, 0.08)`);
      gradient.addColorStop(1, 'transparent');
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }

    function init() {
      canvas = document.getElementById('glow-canvas');
      ctx = canvas.getContext('2d');
      resize();
      window.addEventListener('resize', resize);

      for (let i = 0; i < 12; i++) clouds.push(new Cloud());
      for (let i = 0; i < 60; i++) {
        const spark = new Spark();
        spark.brightness = Math.random() * spark.maxBrightness;
        spark.state = Math.random() > 0.5 ? 'hold' : 'out';
        sparks.push(spark);
      }

      animate();
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    function animate() {
      time++;
      ctx.fillStyle = 'rgba(5, 2, 8, 0.05)';
      ctx.fillRect(0, 0, width, height);

      clouds.forEach(cloud => { cloud.update(); cloud.draw(); });
      drawCentralGlow();
      sparks.forEach(spark => { spark.update(); spark.draw(); });

      requestAnimationFrame(animate);
    }

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
    else init();
  })();
  </script>
</body>
</html>
